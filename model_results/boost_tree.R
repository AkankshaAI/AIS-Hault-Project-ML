### Data Cleaning & wrangling
library(tidyverse) # for general data wrangling and plotting
library(purrr)
library(lubridate) # for working with dates
library(here) # for paths
library(janitor) # for cleaning var names



### ML packages
library(tidymodels)
library(vip)
library(randomForest)
library(ranger) #for random forest
library(xgboost)
library(kableExtra)
library(readr)
library(corrr)
library(corrplot)
library(tune)



load("vessels.RDS")
vessels <- readRDS("rf_tune.RDS")


# Creating a vessels df and filtering for the geartype of choice

vessels_df <- vessels %>%
  filter(vessel_class_gfw %in% c("set_longlines", "set_gillnets", "tuna_purse_seines",	"fishing",
                                 "other_purse_seines","	drifting_longlines")) %>%
  mutate(flag = factor(flag_gfw),
         vessel_class_gfw = factor(vessel_class_gfw))

# Creating a subset of the vessel_df
vessels_sub <- sample_n(vessels_df,10000) %>%
  imputeTS::na.replace(0)

set.seed(3435)

# Split the dataset into train and test

vessels_split <- initial_split(vessels_sub, prop = 0.8, strata = vessel_class_gfw)
vessels_train <- training(vessels_split)
vessels_test <- testing(vessels_split)


#recipe
vessels_recipe <- recipe(vessel_class_gfw ~ length_m_gfw+ mmsi+ tonnage_gt_gfw +
                           fishing_hours_2012 + fishing_hours_2015 + fishing_hours_2018 + fishing_hours_2013 +fishing_hours_2016 + fishing_hours_2019 + fishing_hours_2014 + fishing_hours_2017 + fishing_hours_2020, data = vessels_train) %>%
  step_rollimpute(all_predictors()) %>%
  step_naomit(everything(), skip = TRUE) %>%
  step_dummy(all_nominal_predictors()) %>%
  step_normalize(all_predictors()) %>%
  step_novel(all_nominal(), -all_outcomes()) %>%
  step_zv(all_numeric(), -all_outcomes()) %>%
  step_corr(all_predictors(), threshold = 0.7, method = "spearman")


#folds
set.seed(3435)
vessels_folds <- vfold_cv(data = vessels_train, v = 3, strata = vessel_class_gfw)

boost_model = boost_tree(trees = tune()) %>% #set up boosted tree model
  set_engine("xgboost") %>% # xgboost engine calculates lambda #high lambda is good
  set_mode("classification")


boost_wflw = workflow() %>%
  add_recipe(vessels_recipe) %>%
  add_model(boost_model)

boost_grid <- grid_regular(
  trees(range = c(10,2000)),
  levels = 10)

boost_tune_res <- tune_grid(
  boost_wflw,
  resamples = vessels_folds,
  grid = boost_grid,
  metrics = metric_set(roc_auc)
)

saveRDS(boost_tune_res,file = "boost_tune.RDS")
boost_results <- readRDS("boost_tune.RDS")
# autoplot(boost_results)

autoplot(boost_tune_res)



boost_metrics <- collect_metrics(boost_tune_res) %>%
  arrange(desc((mean)))

best_complexity_boost <- select_best(boost_tune_res)
